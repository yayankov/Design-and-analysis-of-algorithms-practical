/*
ЗАДАЧА – Намери числото!
Супер Любо отново ни изненадва с разностранните си таланти. След като
двоичното търсене му стана скучно, той реши да поразпусне, играейки игра със
своя добър приятел Гошо. Гошо е малко странен(nerdy) и разбирането му за
забава също. Двамата разполагат с k сортирани опашки(всяко добавено число
в опашка е със сигурност по-голямо или равно от предишно добавенето в
същата опашка), които първоначално не съдържат никакви числа. Той казва на
Любо n заявки, като заявките са 2 вида – добави число в i-тата опашка и
намери и изведи най-малкото число от всички опашки. Веднъж намерено, наймалкото число се маха от опашката, на която принадлежи(ако има 2 еднакви по
големина се взима и маха кое да е от 2те).
Вход
На първия ред има 2 числа k и n. Следват n заявки, като заявките са 2 типа:
1 i b – добави числото b в i-тата опашка.
0 – изведи най-малкото число от опашките.
Първото число в заявката определя операцията – 1 за добавяне и 0 за
извеждане. Гарантира се, че при втория тип операции задължително ще има
числа в опашките.
Изход
За всяка операция от втория вид се намира търсеното число и се извежда на
отделен ред.
Ограничения
1 <= k < 100 000
1 <= брой_на_числата_в_опашките <= 100
ПРИМЕРЕН ВХОД
2 8
1 1 2
1 1 4
0
1 2 1
0
0
1 1 5
0
ПРИМЕРЕН ИЗХОД
2
1
4
5
*/
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;



int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n, k;
    cin >> k >> n;
    int operation;
    int q;
    int num;
    priority_queue<int, vector<int>, greater<int>> nums;
    vector<int> res;
    for(int i=0; i<n; i++) {
        cin >> operation;
        if(operation == 1) {
            cin >> q >> num;
            nums.push(num);
        }
        if(operation == 0) {
            res.push_back(nums.top());
            nums.pop();
        }
    }
    for(int ans : res) {
        cout << ans << endl;
    }
    return 0;
}
